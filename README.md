# maze
##使用递归解决迷宫问题



###递归需要遵守的重要原则

1) 执行一个函数时，就创建一个新的受保护的**独立空间**(新函数栈)

2) 函数的局部变量是独立的，不会相互影响, 如果希望各个函数栈使用同一个数据，使用引用传递3) 递归必须向**退出递归的条件逼近**，否则就是无限递归，无法退出

4) 当一个函数执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁

在迷宫问题中，我们需要先确定一个策略，因为我们上下左右四个方向可以选择，具体怎么走，这个该我们自己决定，在此我使用的策略是**下右上左**



##解析 maze/maze/maze.go 文件

#####**在maze包中，我们使用了广度优先算法来计算寻找迷宫最短路径的问题**



###演示不能抵达终点

演示不能抵达终点我们需要打开  **tempFile()**  函数里面的

  mazeMap[3][2] = 1

  mazeMap[3][3] = 1

  mazeMap[3][4] = 1

  data := walk(mazeMap, Point{0, 0}, Point{len(mazeMap) - 1, len(mazeMap[0]) - 1})和对应的判断条件

###演示这是一堵墙，无法到达，不能作为终点

我们需要在任何设定位置是墙的地方设置为终点都可以实现

例如在本代码中，我们打开   **tempFile()**  函数里面的

mazeMap[5][4] = 1

###演示找到迷宫最短路径，你在继续寻找其他路径

为了提升代码的效率，我们找到迷宫最短路径后，没有必要在去寻找其他路径，及时成功也没有必要，因为路径一定是大于或者等于当前路径长度的

为了演示其效果，我们打开   **tempFile()**  函数里面的

// data := walk(mazeMap, Point{0, 0}, Point{3, 2})

// if data != nil && data[3][2] == 0 {

这两句